# 文件名、关键字于标识符
## 文件名
go文件以`.go`后缀存储,文件名均由**小写字母**组成,如果文件名由多个部分组成，则使用下划线`_`对它们进行分隔，如`scanner_test.go`。文件名不包含空格或其他特殊字符。

## 标识符
有效的标识符必须以字符（可以使用任何 UTF-8 编码的字符或`_`）开头，然后紧跟着 0 个或多个字符或 Unicode 数字

`_` 本身就是一个特殊的标识符，被称为**空白标识符**。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。

下面列举了 Go 代码中会使用到的 25 个关键字或保留字：

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <td>break</td>
    <td>default</td>
    <td>func</td>
    <td>interface</td>
    <td>select</td>
  </tr>
  <tr>
    <td>case</td>
    <td>defer</td>
    <td>go</td>
    <td>map</td>
    <td>struct</td>
  </tr>
  <tr>
    <td>chan</td>
    <td>else</td>
    <td>goto</td>
    <td>package</td>
    <td>switch</td>
  </tr>
  <tr>
    <td>const</td>
    <td>fallthrough</td>
    <td>if</td>
    <td>range</td>
    <td>type</td>
  </tr>
  <tr>
    <td>continue</td>
    <td>for</td>
    <td>import</td>
    <td>return</td>
    <td>var</td>
  </tr>
</table>

除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符，其中包含了基本类型的名称和一些基本的内置函数

<table class="table table-bordered table-striped table-condensed">
  <tr>
    <td>append</td>
    <td>bool</td>
    <td>byte</td>
    <td>cap</td>
    <td>close</td>
    <td>complex</td>
    <td>complex64</td>
    <td>complex128</td>
    <td>uint16</td>
  </tr>
  <tr>
    <td>copy</td>
    <td>false</td>
    <td>float32</td>
    <td>float64</td>
    <td>imag</td>
    <td>int</td>
    <td>int8</td>
    <td>int16</td>
    <td>uint32</td>
  </tr>
  <tr>
    <td>int32</td>
    <td>int64</td>
    <td>iota</td>
    <td>len</td>
    <td>make</td>
    <td>new</td>
    <td>nil</td>
    <td>panic</td>
    <td>uint64</td>
  </tr>
  <tr>
    <td>print</td>
    <td>println</td>
    <td>real</td>
    <td>recover</td>
    <td>string</td>
    <td>true</td>
    <td>uint</td>
    <td>uint8</td>
    <td>uintptr</td>
  </tr>
</table>

程序一般由关键字、常量、变量、运算符、类型和函数组成。

程序的代码通过语句来实现结构化。每个语句不需要像 C 家族中的其它语言一样以分号`;`结尾，因为这些工作都将由 Go 编译器自动完成。
# go程序基本结构和要素
## 包的概念、导入与可见性
包是结构化代码的一种方式：每个程序都由包（通常简称为 pkg）的概念组成，可以使用自身的包或者从其它包中导入内容。

每个 Go 文件都属于且仅属于一个包。一个包可以由许多以 .go 为扩展名的源文件组成，因此文件名和包名一般来说都是不相同的。

必须在源文件中非注释的第一行指明这个文件属于哪个包，如：`package main`。`package main`表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 `main`的包。

**标准库**

在 Linux 下，标准库在 Go 根目录下的子目录`pkg\linux_amd64`中。一般情况下，标准包会存放在`$GOROOT/pkg/$GOOS_$GOARCH/`目录下。

**包导入的路径**

1. 如果包名以 `./` 开头，则 Go 会在相对目录中查找；
2. 如果包名以 `/` 开头（在 Windows 下也可以这样使用），则会在系统的绝对路径中查找。
3. 如果包名不是以 `.` 或 `/` 开头，如 `"fmt"` 或者 `"container/list"`，则 Go 会在全局文件进行查找；GOROOT GOPAHT?

**可见性规则**

当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个**大写字母**开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；

标识符如果以小写字母开头，则对包外是不可见的，但是它们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）。

包作为命名空间避免命名冲突：
  - 两个包中的同名变量的区别在于它们的包名，例如 `pack1.Thing` 和 `pack2.Thing`。
  
包的别名来解决包命名冲突：如：`import fm "fmt"`。

**注意事项** 

导入的包名必须必须要使用，否则会报错 `imported and not used: os`

这正是遵循了 Go 的格言：“没有不必要的代码！”

## 函数
**命名方法**
- 只有当某个函数需要被外部包调用的时候才使用大写字母开头，并遵循 Pascal 命名法
- 否则就遵循骆驼命名法，即第一个单词的首字母小写，其余单词的首字母大写。

**符合规范的函数一般写成如下的形式**：

```go
func functionName(parameter_list) (return_value_list) {
   …
}
```

其中：

- parameter_list 的形式为 (param1 type1, param2 type2, …)
- return_value_list 的形式为 (ret1 type1, ret2 type2, …)

**注意**

函数定义时的左大括号 `{` 必须与方法的声明放在同一行，这是编译器的强制规定，否则你在使用 gofmt 时就会出现错误提示，右大括号 `}` 需要被放在紧接着函数体的下一行。如果你的函数非常简短，你也可以将它们放在同一行

	`build-error: syntax error: unexpected semicolon or newline before {`

（这是因为编译器会产生 `func main() ;` 这样的结果，很明显这是错误的）

**Go 语言虽然看起来不使用分号作为语句的结束，但实际上这一过程是由编译器自动完成，因此才会引发像上面这样的错误**

**print与fmt.Print**

单纯地打印一个字符串或变量甚至可以使用预定义的方法来实现，如：`print`、`println：print("ABC")`、`println("ABC")`、`println(i)`（带一个变量 i）。这些函数只可以用于调试阶段，在部署程序的时候务必将它们替换成 `fmt` 中的相关函数。


## 注释
- 行注释：以 `//` 开头的单行注释
- 快注释：多行注释也叫块注释，均已以 `/*` 开头，并以 `*/` 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。

godoc 工具会收集这些注释并产生一个技术文档。
## 类型
- 基本类型：如：int、float、bool、string；
- 结构化类型：如：struct、array、slice、map、channel；
- 只描述行为的：如：interface。

结构化类型以nil作为默认值

一个函数可以拥有多返回值，返回类型之间需要使用逗号分割，并使用小括号 `()` 将它们括起来，如：

```go
func FunctionName (a typea, b typeb) (t1 type1, t2 type2){
  …………
  # 返回的形式
  return var1, var2
}

```
使用 type 关键字义一个已经存在的类型的别名，如：

```go
type IZ int
```
int 是变量 a 的底层类型，这也使得它们之间存在相互转换

如果你有多个类型需要定义，可以使用因式分解关键字的方式，例如：

```go
type (
   IZ int
   FZ float64
   STR string
)
```

每个值都必须在经过编译后属于某个类型（编译器必须能够推断出所有值的类型），因为 Go 语言是一种静态类型语言。

## go程序一般结构
所有的结构将在这一章或接下来的章节中进一步地解释说明，但总体思路如下：

- 在完成包的 import 之后，开始对常量、变量和类型的定义或声明。
- 如果存在 init 函数的话，则对该函数进行定义（这是一个特殊的函数，每个含有该函数的包都会首先执行这个函数）。
- 如果当前包是 main 包，则定义 main 函数。
- 然后定义其余的函数，首先是类型的方法，接着是按照 main 函数中先后调用的顺序来定义相关函数，如果有很多函数，则可以按照字母顺序来进行排序。

Go 程序的执行（程序启动）顺序如下：

1. 按顺序导入所有被 main 包引用的其它包，然后在每个包中执行如下流程：
2. 如果该包又导入了其它的包，则从第一步开始递归执行，但是每个包只会被导入一次。
3. 然后以相反的顺序在每个包中初始化常量和变量，如果该包含有 init 函数的话，则调用该函数。
4. 在完成这一切之后，main 也执行同样的过程，最后调用 main 函数开始执行程序。
## 类型转换
**Go 语言不存在隐式类型转换，因此所有的转换都必须显式说明**
```go
valueOfTypeB = typeB(valueOfTypeA)
```

具有相同底层类型的变量之间可以相互转换：

```go
var a IZ = 5
c := int(a)
d := IZ(c)
```

只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（例如将 int16 转换为 int32）

当从一个取值范围较大的转换到取值范围较小的类型时（例如将 int32 转换为 int16 或将 float32 转换为 int），会发生精度丢失（截断）的情况。当编译器捕捉到非法的类型转换时会引发编译时错误，否则将引发运行时错误。？

## go命名规范
名称不需要指出自己所属的包，因为在调用的时候会使用包名作为限定符。

返回某个对象的函数或方法的名称一般都是使用名词，没有 `Get...` 之类的字符。

如果是用于修改某个对象，则使用 `SetName。

有必须要的话可以使用大小写混合的方式，如 MixedCaps 或 mixedCaps，而不是使用下划线来分割多个名称。

# 常量
常量使用关键字 `const` 定义，存储不会改变的数据。

存储在常量中的数据类型只可以是**布尔型、数字型（整数型、浮点型和复数）和字符串型**。

常量的定义格式：`const identifier [type] = value`

在 Go 语言中，你可以省略类型说明符 `[type]`，因为编译器可以根据变量的值来推断其类型。

- 显式类型定义： `const b string = "abc"`
- 隐式类型定义： `const b = "abc"`

常量的值必须是能够在编译时就能够确定的；你可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。因为在编译期间自定义函数均属于未知，因此无法用于常量的赋值，但内置函数可以使用，如：len()

常量也允许使用并行赋值的形式：

```go
const beef, two, c = "eat", 2, "veg"
const Monday, Tuesday, Wednesday, Thursday, Friday, Saturday = 1, 2, 3, 4, 5, 6
const (
	Monday, Tuesday, Wednesday = 1, 2, 3
	Thursday, Friday, Saturday = 4, 5, 6
)
```

## 枚举
常量还可以用作枚举：

```go
const (
	Unknown = 0
	Female = 1
	Male = 2
)
```

现在，数字 0、1 和 2 分别代表未知性别、女性和男性。这些枚举值可以用于测试某个变量或常量的实际值，比如使用 switch/case 结构.

在这个例子中，`iota` 可以被用作枚举值：

```go
const (
	a = iota
	b = iota
	c = iota
)
```

第一个 `iota` 等于 0，每当 `iota` 在新的一行被使用时，它的值都会自动加 1，并且没有赋值的常量默认会应用上一行的赋值表达式：

```go
// 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式
const (
	a = iota  // a = 0
	b         // b = 1
	c         // c = 2
	d = 5     // d = 5   
	e         // e = 5
)

// 赋值两个常量，iota 只会增长一次，而不会因为使用了两次就增长两次
const (
	Apple, Banana = iota + 1, iota + 2 // Apple=1 Banana=2
	Cherimoya, Durian                  // Cherimoya=2 Durian=3
	Elderberry, Fig                    // Elderberry=3, Fig=4

)

// 使用 iota 结合 位运算 表示资源状态的使用案例
const (
	Open = 1 << iota  // 0001
	Close             // 0010
	Pending           // 0100
)

const (
	_           = iota             // 使用 _ 忽略不需要的 iota
	KB = 1 << (10 * iota)          // 1 << (10*1)
	MB                             // 1 << (10*2)
	GB                             // 1 << (10*3)
	TB                             // 1 << (10*4)
	PB                             // 1 << (10*5)
	EB                             // 1 << (10*6)
	ZB                             // 1 << (10*7)
	YB                             // 1 << (10*8)
)
```

# 变量
## 简介
**变量的声明**

声明变量的一般形式是使用 `var` 关键字：`var identifier type`。

```go
var a, b *int
```

这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解。

示例：

```go
var a int
var b bool
var str string
```

改写：

```go
var (
	a int
	b bool
	str string
)
```

这种因式分解关键字的写法一般用于声明全局变量。

**变量初值**

当一个变量被声明之后，系统自动赋予它该类型的零值：

- int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil。

所有的内存在 Go 中都是经过初始化的。

**命名规则**

变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：`numShips` 和 `startDate`。

你的全局变量希望能够被外部包所使用，则需要将首个单词的首字母也大写

**作用域**

如果一个变量在函数体外声明，则被认为是**全局变量**，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。

在函数体内声明的变量称之为**局部变量**，它们的作用域只在函数体内，参数和返回值变量也是局部变量。 if 和 for 这些控制结构，而在这些结构中声明的变量的作用域只在相应的代码块内。一般情况下，局部变量的作用域可以通过代码块（用大括号括起来的部分）判断。

**变量的标识符必须是唯一**的，在某个代码块的内层代码块中使用相同名称的变量时，外部的同名变量将会暂时隐藏（结束内部代码块的执行后隐藏的外部同名变量又会出现，而内部同名变量则被释放），任何的操作都只会影响内部代码块的局部变量。

**变量赋值**

变量可以编译期间就被赋值，赋值给变量使用运算符等号 `=`，当然你也可以在运行时对变量进行赋值操作。示例：

```go
a = 15
b = false
```

一般情况下，当变量a和变量b之间类型相同时，才能进行如`a = b`的赋值。

声明与赋值（初始化）语句也可以组合起来。

Go 编译器的智商已经高到可以根据变量的值来自动推断其类型

```go
var a = 15
var b = false
var str = "Go says hello to the world!"
```
自动推断类型并不是任何时候都适用的，当你想要给变量的类型并不是自动推断出的某种类型时，你还是需要显式指定变量的类型，例如：

```go
var n int64 = 2
```

`var a` 这种语法是不正确的，因为编译器没有任何可以用于自动推断类型的依据。

`var`这种写法主要用于声明包级全局变量，函数体内声明局部变量时，应使用简短声明语法 `:=`，例如：

```go
a := 1
```
## 值类型和引用类型
**值类型**
- int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值
- 数组（第 7 章）和结构（第 10 章）这些复合类型也是值类型。

当使用等号 `=` 将一个变量的值赋值给另一个变量时，如：`j = i`，实际上是在内存中将 i 的值进行了拷贝：

**引用类型**

更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。
- 指针， slices，maps 和 channel 属于引用类型
- 被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。

一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。

同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。

当使用赋值语句 `r2 = r1` 时，只有引用（地址）被复制。

如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。

## 打印
函数 `Printf` 可以在 fmt 包外部使用，这是因为它以大写字母 P 开头，该函数主要用于打印输出到控制台。通常使用的格式化字符串作为第一个参数：

```go
func Printf(format string, list of variables to be printed)
```

这个格式化字符串可以含有一个或多个的格式化标识符，例如：`%..`，其中 `..` 可以被不同类型所对应的标识符替换，如 `%s` 代表字符串标识符、`%v` 代表使用类型的默认输出格式的标识符。这些标识符所对应的值从格式化字符串后的第一个逗号开始按照相同顺序添加，如果参数超过 1 个则同样需要使用逗号分隔。使用这些占位符可以很好地控制格式化输出的文本。

函数 `fmt.Sprintf` 与 `Printf` 的作用是完全相同的，不过**前者将格式化后的字符串以返回值的形式返回给调用者**，因此你可以在程序中使用包含变量的字符串

函数 `fmt.Print` 和 `fmt.Println` 会自动使用格式化标识符 `%v` 对字符串进行格式化，两者都会在每个参数之间自动增加空格，而后者还会在字符串的最后加上一个换行符。例如：

```go
fmt.Print("Hello:", 23)
```

将输出：`Hello: 23`。

## 简短形式 ：=操作符
使用操作符 `:=` 可以高效地在函数体内创建一个新的变量，称之为初始化声明。

这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。

在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明,但可以赋值。

声明了一个局部变量却没有在相同的代码块中使用它，会得到编译错误，但是全局变量是允许声明但不使用。

同一类型的多个变量可以声明在同一行，如：

```go
var a, b, c int
```

(这是将类型写在标识符后面的一个重要原因)

**并行或同时赋值**

多变量可以在同一行进行赋值，如：

```go
a, b, c = 5, 7, "abc"
```

上面这行假设了变量 a，b 和 c 都已经被声明，否则的话应该这样使用：

```go
a, b, c := 5, 7, "abc"
```

右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 `5`， b 的值是 `7`，c 的值是 `"abc"`。

交换两个变量的值，可以简单地使用 `a, b = b, a`。

并行赋值也被用于当一个函数返回多个返回值时，比如这里的 `val` 和错误 `err` 是通过调用 `Func1` 函数同时得到：`val, err = Func1(var1)`。

**只写变量**

空白标识符 `_` 也被用于抛弃值，如值 `5` 在：`_, b = 5, 7` 中被抛弃。

`_` 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。

## init函数

# 基本类型和运算符
一元运算符只可以用于一个值的操作（作为后缀），而二元运算符则可以和两个值或者操作数结合（作为中缀）。只有两个类型相同的值才可以和二元运算符结合

Go 是强类型语言，因此不会进行隐式转换，任何不同类型之间的转换都必须显式说明。

Go 不存在像 C 那样的运算符重载，表达式的解析顺序是从左至右。
## 布尔类型bool
一个简单的例子：`var b bool = true`。

布尔型的值只可以是常量 true 或者 false。

两个类型相同的值可以使用相等 `==` 或者不等 `!=` 运算符来进行比较并获得一个布尔型的值。

Go 对于值之间的比较有非常严格的限制
- 只有两个类型相同的值才可以进行比较，
- 如果值的类型是接口，它们也必须都实现了相同的接口。
- 如果其中一个值是常量，那么另外一个值的类型必须和该常量类型相兼容的。
- 如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同之后才可以进行比较。

在 Go 语言中，&& 和 || 是具有快捷性质的运算符，当运算符左边表达式的值已经能够决定整个表达式的值的时候,运算符右边的表达式将不会被执行。利用这个性质，如果你有多个条件判断，应当将计算过程较为复杂的表达式放在运算符的右侧以减少不必要的运算。
- && 左边的值为 false
- || 左边的值为 true），

在格式化输出时，你可以使用 `%t` 来表示你要输出的值为布尔型。

对于布尔值的好的命名能够很好地提升代码的可读性，例如以 `is` 或者 `Is` 开头的 `isSorted`、`isFinished`、`isVisible`，使用这样的命名能够在阅读代码的获得阅读正常语句一样的良好体验，例如标准库中的 `unicode.IsDigit(ch)`


## 数字类型
### 整形int和浮点型float
Go 语言支持整型和浮点型数字，并且原生支持复数，其中位的运算采用补码

Go 语言中没有 float 类型。（Go语言中只有 float32 和 float64）没有double类型。

整数：

- int8（-128 -> 127）
- int16（-32768 -> 32767）
- int32（-2,147,483,648 -> 2,147,483,647）
- int64（-9,223,372,036,854,775,808 -> 9,223,372,036,854,775,807）

无符号整数：

- uint8（0 -> 255）
- uint16（0 -> 65,535）
- uint32（0 -> 4,294,967,295）
- uint64（0 -> 18,446,744,073,709,551,615）

浮点型（IEEE-754 标准）：

- float32（+- 1e-45 -> +- 3.4 * 1e38）
- float64（+- 5 * 1e-324 -> 107 * 1e308）

float32 精确到小数点后 7 位，float64 精确到小数点后 15 位。由于精确度的缘故，你在使用 == 或者 != 来比较浮点数时应当非常小心。你最好在正式使用前测试对于精确度要求较高的运算。

使用 float64，因为 `math` 包中所有有关数学运算的函数都会要求接收这个类型。

**格式化说明符**

- `%d` 用于格式化整数（`%x` 和 `%X` 用于格式化 16 进制表示的数字）
- `%g` 用于格式化浮点型（`%f` 输出浮点数，`%e` 输出科学计数表示）
- `%0nd` 用于规定输出长度为 n 的整数，其中开头的数字 0 是必须的。
- `%n.mg` 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串 `%5.2e` 来输出 3.4 的结果为 `3.40e+00`。
## 运算符与优先级
## 类型别名
## 字符类型
# 字符串
# strings包和strconv包
# 时间和日期
# 指针