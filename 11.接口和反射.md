# 接口
go没有类和继承的概念，但可以使用灵活的接口实现很多面向对象的特性。

接口定义了一组方法集，但不包含实现代码：它们没有被实现(它们是抽象的)。接口也不包含变量。

通过如下格式定义接口：

```go
type Namer interface {
    Method1(param_list) return_type
    Method2(param_list) return_type
    ...
}
```
上面的 `Namer` 是一个 **接口类型**。

按约定，接口只包含一个方法时，接口的名字由方法名加`er`后缀组成，如`Printer`、`Reader`、`Writer`、`Logger`、`Converter` 等等。当后缀 `er` 不合适时，可以一`able`结尾，比如 `Recoverable`，此时接口名以 `able` 结尾，或者以 `I` 开头

Go 语言中的接口都很简短，通常它们会包含 0 个、最多 3 个方法。

接口可以有值，它的本质是一个指针。`var ai Namer`，`ai`是一个多字数据，它的值为nil。

![](image/11.1_fig11.1.jpg)

实现了`Namer`接口的类型变量可以赋值给ai(`receiver`),方法表指针(method table ptr)就指向了当前方法的实现。当另一个实现了`Namer`接口的类型变量赋值给`ai`时，`receiver`的值和方法表指针的值也会相应改变。

[interfaces.go](examples/chapter_10/interfaces.go):

```go
package main
​
import "fmt"
​
type Shaper interface {
    Area() float32
}
​
type Square struct {
    side float32
}
​
func (sq *Square) Area() float32 {
    return sq.side * sq.side
}
​
func main() {
    sq1 := new(Square)
    sq1.side = 5
​
    var areaIntf Shaper
    areaIntf = sq1
    // shorter,without separate declaration:
    // areaIntf := Shaper(sq1)
    // or even:
    // areaIntf := sq1
    fmt.Printf("The square has area: %f\n", areaIntf.Area())
}
```
输出：
```
The square has area: 25.000000
```
在 `main()` 方法中创建了一个 `Square` 的实例。在主程序外边定义了一个接收者类型是 `Square` 方法的 `Area()`，用来计算正方形的面积：结构体 `Square` 实现了接口 `Shaper` 。

所以可以将一个 `Square` 类型的变量赋值给一个接口类型的变量：`areaIntf = sq1` 。

现在接口变量包含一个指向 `Square` 变量的引用，通过它可以调用 `Square` 上的方法 `Area()`。当然也可以直接在 `Square` 的实例上调用此方法，但是在接口实例上调用此方法更令人兴奋，它使此方法更具有一般性。接口变量里包含了接收者实例的值和指向对应方法表的指针。

这是 **多态** 的 Go 版本，多态是面向对象编程中一个广为人知的概念：根据当前的类型选择正确的方法，或者说：同一种类型在不同的实例上似乎表现出不同的行为。

如果 `Square` 没有实现 `Area()` 方法，编译器将会给出清晰的错误信息：

    cannot use sq1 (type *Square) as type Shaper in assignment:
    *Square does not implement Shaper (missing Area method)

如果 `Shaper` 有另外一个方法 `Perimeter()`，但是`Square` 没有实现它，即使没有人在 `Square` 实例上调用这个方法，编译器也会给出上面同样的错误。

# 接口嵌套接口
# 类型断言
# 类型判断
# 测试是否实现接口
# 使用方法集与接口
# 例子：Sorter接口排序
# 例子：读和写
# 空接口
# 反射包
# 接口与动态特性
# go中的面向对象
# 结构体、集合、高阶函数