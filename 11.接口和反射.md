# 接口
go没有类和继承的概念，但可以使用灵活的接口实现很多面向对象的特性。

接口定义了一组方法集，但不包含实现代码：它们没有被实现(它们是抽象的)。接口也不包含变量。

通过如下格式定义接口：

```go
type Namer interface {
    Method1(param_list) return_type
    Method2(param_list) return_type
    ...
}
```
上面的 `Namer` 是一个 **接口类型**。

按约定，接口只包含一个方法时，接口的名字由方法名加`er`后缀组成，如`Printer`、`Reader`、`Writer`、`Logger`、`Converter` 等等。当后缀 `er` 不合适时，可以一`able`结尾，比如 `Recoverable`，此时接口名以 `able` 结尾，或者以 `I` 开头

Go 语言中的接口都很简短，通常它们会包含 0 个、最多 3 个方法。

接口可以有值，它的本质是一个指针。`var ai Namer`，`ai`是一个多字数据，它的值为nil。

![](image/11.1_fig11.1.jpg)

实现了`Namer`接口的类型变量可以赋值给ai(`receiver`),方法表指针(method table ptr)就指向了当前方法的实现。当另一个实现了`Namer`接口的类型变量赋值给`ai`时，`receiver`的值和方法表指针的值也会相应改变。

[interfaces.go](examples/chapter_10/interfaces.go):

```go
package main
​
import "fmt"
​
type Shaper interface {
    Area() float32
}
​
type Square struct {
    side float32
}
​
func (sq *Square) Area() float32 {
    return sq.side * sq.side
}
​
func main() {
    sq1 := new(Square)
    sq1.side = 5
​
    var areaIntf Shaper
    areaIntf = sq1
    // shorter,without separate declaration:
    // areaIntf := Shaper(sq1)
    // or even:
    // areaIntf := sq1
    fmt.Printf("The square has area: %f\n", areaIntf.Area())
}
```
输出：
```
The square has area: 25.000000
```
在 `main()` 方法中创建了一个 `Square` 的实例。在主程序外边定义了一个接收者类型是 `Square` 方法的 `Area()`，用来计算正方形的面积：结构体 `Square` 实现了接口 `Shaper` 。

所以可以将一个 `Square` 类型的变量赋值给一个接口类型的变量：`areaIntf = sq1` 。

现在接口变量包含一个指向 `Square` 变量的引用，通过它可以调用 `Square` 上的方法 `Area()`。当然也可以直接在 `Square` 的实例上调用此方法，

**但是在接口实例上调用此方法更令人兴奋，它使此方法更具有一般性。接口变量里包含了接收者实例的值和指向对应方法表的指针。**

这是 **多态** 的 Go 版本，多态是面向对象编程中一个广为人知的概念：根据当前的类型选择正确的方法，或者说：同一种类型在不同的实例上似乎表现出不同的行为。

如果 `Square` 没有实现 `Area()` 方法，编译器将会给出清晰的错误信息：

    cannot use sq1 (type *Square) as type Shaper in assignment:
    *Square does not implement Shaper (missing Area method)

如果 `Shaper` 有另外一个方法 `Perimeter()`，但是`Square` 没有实现它，即使没有人在 `Square` 实例上调用这个方法，编译器也会给出上面同样的错误。

# 接口嵌套接口
一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。

比如接口 `File` 包含了 `ReadWrite` 和 `Lock` 的所有方法，它还额外有一个 `Close()` 方法。

```go
type ReadWrite interface {
    Read(b Buffer) bool
    Write(b Buffer) bool
}

type Lock interface {
    Lock()
    Unlock()
}

type File interface {
    ReadWrite
    Lock
    Close()
}
```

# 类型断言
一个接口类型的变量`varI`可以包含任何类型的值，是一种动态类型，即运行时变量中存储值的实际类型会发生变化。

类型断言：检测某时刻接口`varI`是否包含类型`T`的值。


```go
v := varI.(T)       // unchecked type assertion
```

更安全的方式：

```go
if v, ok := varI.(T); ok {  // checked type assertion
    Process(v)
    return
}
// varI is not of type T
```
当转换合法时，`v` 是 `varI` 转换到类型 `T` 的值，`ok` 会是 `true`；

否则 `v` 是类型 `T` 的零值，`ok` 是 `false`，也没有运行时错误发生。

# 类型判断:type-switch
接口变量的类型也可以使用一种特殊形式的 `switch` 来检测：**type-switch** （下面是示例 11.4 的第二部分）：

```go
switch t := areaIntf.(type) {
case *Square:
	fmt.Printf("Type Square %T with value %v\n", t, t)
case *Circle:
	fmt.Printf("Type Circle %T with value %v\n", t, t)
case nil:
	fmt.Printf("nil value: nothing to check?\n")
default:
	fmt.Printf("Unexpected type %T\n", t)
}
```

输出：

    Type Square *main.Square with value &{5}

# 测试是否实现接口

# 使用方法集与接口
**总结**

在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以根据具体类型 `P` 直接辨识的：

- 指针方法可以通过指针调用
- 值方法可以通过值调用
- 接收者是值的方法可以通过指针调用，因为指针会首先被解引用
- 接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址

将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值上被调用，因此不正确的赋值在编译期就会失败。

Go 语言规范定义了接口方法集的调用规则：

- 类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集
- 类型 T 的可调用方法集包含接受者为 T 的所有方法
# 例子：Sorter接口排序
# 例子：读和写
# 空接口
# 反射包
# 接口与动态特性
# go中的面向对象
# 结构体、集合、高阶函数